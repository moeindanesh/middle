/**
 * TODO:
 *  channelClosing?: boolean | undefined
 * channelClosingAt?: number | undefined
 */

import ms from 'ms'
import { EventEmitter } from './event-emitter'
import errorCode from 'err-code'
import { nanoid } from 'nanoid/non-secure'

export type IceServer = {
  url: string
  urls: string
  username?: string
  credential?: string
}

const debug = require('debug')('desktop:rtc')

declare global {
  interface RTCPeerConnection extends EventTarget {
    // Patch, until TS fixes it: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/966
    setLocalDescription(description?: RTCSessionDescriptionInit): Promise<void>
  }
}

type SignalData = RTCSessionDescriptionInit | RTCIceCandidateInit
export type RtcSignalData = { signal: SignalData }
type RemoteSignalData = RtcSignalData
type SdpTransform = (
  sdp: RTCSessionDescriptionInit,
) => RTCSessionDescriptionInit
interface Input<TrackNames extends string> {
  polite: boolean
  /** Advised to have impolite peer be the offerer */
  initialOfferer: boolean
  iceServers?: IceServer[]
  sdpTransform?: SdpTransform
  tracks: TracksConfig<TrackNames>
}

type Jsonable = Record<string, string | number | boolean | unknown>
type InternalDataMessage =
  | {
      __type: 'signal'
      payload: { signal: SignalData; pairId: number }
    }
  | { __type: 'close' }

type ErrorCodes =
  | 'ERR_WEBRTC_SUPPORT'
  | 'ERR_CREATE_OFFER'
  | 'ERR_CREATE_ANSWER'
  | 'ERR_SET_LOCAL_DESCRIPTION'
  | 'ERR_SET_REMOTE_DESCRIPTION'
  | 'ERR_ADD_ICE_CANDIDATE'
  | 'ERR_ICE_CONNECTION_FAILURE'
  | 'ERR_ICE_RESTART_FAILURE'
  | 'ERR_SIGNALING'
  | 'ERR_DATA_CHANNEL'
  | 'ERR_CONNECTION_FAILURE'

export type RtcConnectionStateType = 'connected' | 'connecting' | 'closed'
// counted after the "connected" event
const NO_MEDIA_TIMEOUT = ms('4s')
const OFFER_TIMEOUT_MIN = ms('3s')
const ICERESTART_TIMEOUT = ms('8s')
const CHANNEL_CLOSING_TIMEOUT = ms('5s')
const NO_ANSWER_TIMEOUT = ms('10s')
const CONNECTION_TIMEOUT = ms('30s')
const MAX_BUFFERED_AMOUNT = 64 * 1024

interface TrackConfig {
  kind: 'audio' | 'video'
  track: MediaStreamTrack | null
  /** Tracks that have identical stream keys will be attached to a common stream */
  streamKey: string
}
type TracksConfig<TrackName extends string> = Map<TrackName, TrackConfig>
export type RtcTracksConfig<TrackName extends string> = TracksConfig<TrackName>

export class RtcPeer<TrackName extends string> extends EventEmitter {
  input: Input<TrackName>

  peer: RTCPeerConnection | undefined
  dataChannel?: RTCDataChannel
  sdpTransform: SdpTransform
  /** Generated by the offerer and used to filter out non-offer signals related to an old peer */
  currentPairId: number | undefined
  id: string

  // flags
  polite: boolean
  initialOfferer: boolean
  makingOffer?: boolean
  destroyed: boolean
  destroying: boolean
  connectionReady: boolean
  channelReady: boolean
  flushingIceQueue: boolean
  restartingIce: boolean
  needsIceRestart: boolean
  state: RtcConnectionStateType
  settingRemoteAnswer: boolean
  ignoredOffer: boolean
  negotiationCount: number

  //. Internal
  remoteTracks: Set<MediaStreamTrack>
  localTracks: TracksConfig<TrackName>
  senders: Map<TrackName, RTCRtpSender>
  readonly internalStreams: Map<string, MediaStream>
  timerId: number | undefined
  iceCandidatesQueue: Array<RTCIceCandidateInit>

  addListener(event: 'track', cb: (event: RTCTrackEvent) => void): void
  addListener(event: 'signal', cb: (signalData: RtcSignalData) => void): void
  addListener(
    event: 'connectionStateChange',
    cb: (connectionState: RtcConnectionStateType) => void,
  ): void
  addListener(event: 'error', cb: (error: Error) => void): void
  addListener(event: 'data', cb: (data: any) => void): void
  addListener(event: 'dataOpen', cb: () => void): void
  addListener(event: string, cb: (...args: any) => void) {
    super.addListener(event, cb)
  }

  get impolite() {
    return !this.polite
  }

  static defaultIceServers = [
    {
      urls: ['stun:stun.l.google.com:19302'],
    },
  ]

  constructor(input: Input<TrackName>) {
    super()

    // Setup input
    this.input = input
    this.sdpTransform = sdp => sdp
    this.polite = input.polite
    this.state = 'connecting'

    // Initialize flags
    this.initialOfferer = input.initialOfferer
    this.destroyed = false
    this.destroying = false
    this.connectionReady = false
    this.channelReady = false
    this.restartingIce = false
    this.needsIceRestart = false
    this.currentPairId = undefined
    this.settingRemoteAnswer = false
    this.flushingIceQueue = false
    this.ignoredOffer = false
    this.negotiationCount = 0

    this.id = nanoid(6)
    this.timerId = undefined
    this.remoteTracks = new Set()
    this.localTracks = input.tracks
    this.senders = new Map()
    this.internalStreams = new Map()
    this.iceCandidatesQueue = []

    // Bind fuckers
    this.handleNegotiationNeeded = this.handleNegotiationNeeded.bind(this)
    this.handleConnectionStateChange = this.handleConnectionStateChange.bind(
      this,
    )
    this.handleIceCandidate = this.handleIceCandidate.bind(this)
    this.handleTrack = this.handleTrack.bind(this)
    this.handleIceConnectionStateChange = this.handleIceConnectionStateChange.bind(
      this,
    )
    this.handleIceGatheringStateChange = this.handleIceGatheringStateChange.bind(
      this,
    )
    this.handleNegotiationNeeded = this.handleNegotiationNeeded.bind(this)
    this.handleSignalingStateChange = this.handleSignalingStateChange.bind(this)
    this.handleDataChannel = this.handleDataChannel.bind(this)
    this.setupDataChannel = this.setupDataChannel.bind(this)

    // Initialize peer connection
    this.startPeerConnection()
  }

  private startPeerConnection() {
    this.debug(
      `starting new RTCPeerConnection (polite=${this.polite}, initialOfferer=${this.initialOfferer})`,
    )

    this.destroyed = false

    // To be safe that no other peer will be created as an artifact from the past
    this.stopTimers()

    this.setConnectionState('connecting')

    try {
      this.peer = new RTCPeerConnection({
        iceServers: this.input.iceServers || RtcPeer.defaultIceServers,
        // @ts-ignore
        sdpSemantics: 'unified-plan',
      })
    } catch (error) {
      // queueMicrotask(() => this.destroy(errorCode(error, 'ERR_PC_CONSTRUCTOR')))
      this.destroy(errorCode(error, 'ERR_PC_CONSTRUCTOR'))
    }

    if (!this.peer) {
      this.destroy(errorCode(new Error('Peer undefined'), 'ERR_PC_CONSTRUCTOR'))
      return
    }

    // Attach event handlers
    this.peer?.addEventListener(
      'connectionstatechange',
      this.handleConnectionStateChange,
    )
    this.peer?.addEventListener('icecandidate', this.handleIceCandidate)
    this.peer?.addEventListener('track', this.handleTrack)
    this.peer?.addEventListener(
      'iceconnectionstatechange',
      this.handleIceConnectionStateChange,
    )
    this.peer?.addEventListener(
      'icegatheringstatechange',
      this.handleIceGatheringStateChange,
    )
    this.peer?.addEventListener('datachannel', this.handleDataChannel)
    this.peer?.addEventListener(
      'negotiationneeded',
      this.handleNegotiationNeeded,
    )
    this.peer?.addEventListener(
      'signalingstatechange',
      this.handleSignalingStateChange,
    )

    // add transceivers on impolite side
    if (this.initialOfferer) {
      // Data channel (non-negotiated as negotiated was flaky)
      this.dataChannel = this.peer.createDataChannel('main')
      this.setupDataChannel(this.dataChannel)
    }

    if (this.initialOfferer) {
      // Add before offer
      // DEBUG
      this.addInitialTracks()

      this.debug('sending initial offer (initialOfferer)')
      this.sendOffer()
    } else {
      // if not the first negotiation
      // if (this.negotiationCount > 1) {
      this.sendOffer()
      // }
    }
  }

  private handleConnectionStateChange() {
    if (this.destroyed) return
    if (!this.peer) return

    let connectionState = this.peer.connectionState
    if (connectionState === 'failed') {
      this.debug('connectionState=', 'failed')

      // DEBUG FOR ICE RESTART
      // this.failed(
      //   RtcPeer.errorCode(
      //     new Error('Connection failed.'),
      //     'ERR_CONNECTION_FAILURE',
      //   ),
      // )
    }

    if (connectionState === 'closed') {
      this.debug('connectionState= closed')
      // Simple peer doesn't close
      // this.destroy()
      // this.stopIceRestartTimeout()
    }

    if (connectionState === 'connected') {
      // handle connect
      this.connectionReady = true
      this.setConnectionState('connected')
    }
  }

  private async sendOffer() {
    if (this.makingOffer) {
      this.debug('Called sendOffer when we were making offer')
      return
    }

    if (!this.connectionTimeoutId && this.state !== 'connected') {
      this.startConnectionTimeout()
    }

    this.makingOffer = true
    try {
      let offer = await this.peer?.createOffer()

      if (!offer) return

      let changedOffer = this.sdpTransform(offer)

      // Taken from: https://blog.mozilla.org/webrtc/perfect-negotiation-in-webrtc/
      if (this.peer?.signalingState !== 'stable') {
        this.debug('signalingState not stable: drop offer')
        return
      }

      await this.peer
        ?.setLocalDescription(changedOffer)
        .catch(this.catchError('ERR_SET_LOCAL_DESCRIPTION'))

      let offerToSend = this.peer?.localDescription || changedOffer

      if (this.peer?.localDescription !== changedOffer) {
        this.debug('[warn] MISMATCH')
      }

      // Send initial offer!
      this.sendSignal({ signal: offerToSend })
    } catch (error) {
      this.failed(RtcPeer.errorCode(error, 'ERR_CREATE_OFFER'))
    } finally {
      this.makingOffer = false
    }
  }

  private handleIceCandidate(event: RTCPeerConnectionIceEvent) {
    if (this.destroyed) return

    if (event.candidate) {
      this.sendSignal({ signal: event.candidate })
    }
  }

  /**
   * Called on both statechange and gatheringstatechange
   **/
  private handleIceStateChange() {
    if (this.destroyed) return
    if (!this.peer) return

    const iceConnectionState = this.peer.iceConnectionState
    const iceGatheringState = this.peer.iceGatheringState

    this.debug(
      'iceStateChange (connection: %s) (gathering: %s)',
      iceConnectionState,
      iceGatheringState,
    )

    if (
      iceConnectionState === 'connected' ||
      iceConnectionState === 'completed'
    ) {
      this.connectionReady = true
      this.restartingIce = false
      this.needsIceRestart = false
      this.stopIceRestartTimeout()
      this.setConnectionState('connected')
    }

    // Should we also include disconnected?
    else if (
      iceConnectionState === 'disconnected' ||
      iceConnectionState === 'failed'
    ) {
      if (!this.restartingIce) {
        this.debug('Needs ICE restart.')
        this.needsIceRestart = true

        // Immediately restart for now (until we await connection)
        this.restartIce()
      } else if (this.restartingIce && iceGatheringState === 'complete') {
        this.debug('Ice restart failed.')

        this.failed(
          RtcPeer.errorCode(
            new Error('Ice restart failed.'),
            'ERR_ICE_RESTART_FAILURE',
          ),
        )
      }
    }
    // Closed
    else if (iceConnectionState === 'closed') {
      this.failed(
        RtcPeer.errorCode(
          new Error('Ice connection closed.'),
          'ERR_ICE_CONNECTION_FAILURE',
        ),
      )
    }
  }

  private handleIceConnectionStateChange() {
    this.handleIceStateChange()
  }

  private handleIceGatheringStateChange() {
    this.handleIceStateChange()
  }

  private handleTrack(event: RTCTrackEvent) {
    this.debug('[handleTrack]')
    if (this.destroyed) {
      return
    }

    if (event.track) {
      this.remoteTracks.add(event.track)
    }

    this.stopNoMediaTimeout()
    this.emit('track', event)
  }

  addTrack(
    trackName: TrackName,
    track: MediaStreamTrack,
  ): RTCRtpSender | undefined {
    if (this.destroyed || !this.peer) return

    let config = this.localTracks.get(trackName)

    if (!config) {
      console.error(
        'addTrack called with a track name that has not been initialized to the peer constructor.',
      )
      return
    }

    if (this.senders.get(trackName)) {
      // Already added
      this.debug(
        '[warn] addTrack was called with a track that is already added',
      )
      return
    }

    if (!track || !(track instanceof MediaStreamTrack)) {
      console.error(
        'addTrack was called without a valid track',
        trackName,
        track,
      )
      return
    }

    let { streamKey } = config

    // Fetch stream
    let stream = this.getStream(streamKey, track)

    // Add on peer
    let sender = this.peer.addTrack(track, stream)

    // Save sender
    this.senders.set(trackName, sender)

    // Update localTrack for future reconnects
    this.updateLocalTracks(trackName, track)

    return sender
  }

  warmUpTransceiver(trackName: TrackName): RTCRtpSender | undefined {
    if (this.destroyed || !this.peer) return

    let config = this.localTracks.get(trackName)

    if (!config) {
      console.error(
        'warmUp called with a track name that has not been initialized to the peer constructor.',
      )
      return
    }

    if (this.senders.get(trackName)) {
      // Already added
      this.debug('[warn] warmUp was called with a track that is already added')
      return
    }

    let { sender } = this.peer.addTransceiver(config.kind, {
      direction: 'sendrecv',
    })

    this.debug('Warmed up transceiver, kind =', config.kind)

    // Save sender
    this.senders.set(trackName, sender)

    return sender
  }

  updateLocalTracks(trackName: TrackName, track: MediaStreamTrack | null) {
    let config = this.localTracks.get(trackName)

    if (!config) {
      this.failed(
        new Error('Track name was not initialized in the peer constructor.'),
      )
      return
    }

    this.localTracks.set(trackName, {
      ...config,
      track,
    })
  }

  /** A very new method that handles adding, replacing, muting tracks */
  setTrack(trackName: TrackName, track: MediaStreamTrack) {
    let sender = this.senders.get(trackName)

    if (sender) {
      if (sender.track?.id === track.id) {
        // Skip
        this.debug('[setTrack] skipped')
        return
      }

      this.replaceTrack(trackName, track)
    } else {
      sender = this.addTrack(trackName, track)
    }

    return sender
  }

  private getStream(streamKey: string, track: MediaStreamTrack) {
    let stream = this.internalStreams.get(streamKey)

    if (stream) {
      stream.addTrack(track)
    } else {
      stream = new MediaStream([track])
    }

    this.internalStreams.set(streamKey, stream)

    return stream
  }

  getSenders() {
    return this.peer?.getSenders()
  }

  replaceTrack(trackName: TrackName, newTrack: MediaStreamTrack | null) {
    if (this.destroyed || !this.peer) return

    let sender = this.senders.get(trackName)

    if (!sender) {
      console.error(`[replaceTrack] Track has not been sent before. Aborting.`)
      return
    }

    sender.replaceTrack(newTrack)

    // Update localTrack for future reconnects
    this.updateLocalTracks(trackName, newTrack)

    this.debug('[replaceTrack] succeeded')
    return sender
  }

  /**
   * Perfect negotiation
   */
  async setRemoteSignal(signalData: RemoteSignalData) {
    if (this.destroyed || this.destroying || !this.peer) {
      this.debug(
        `Got remote signal when destroyed or no peer (state=${this.state})`,
      )
      return
    }

    let type = 'type' in signalData.signal ? signalData.signal.type : undefined

    try {
      // sdp
      if ('sdp' in signalData.signal) {
        const isOffer = type === 'offer'
        const isAnswer = type === 'answer'

        let isStable =
          this.peer.signalingState === 'stable' ||
          (this.peer.signalingState === 'have-local-offer' &&
            this.settingRemoteAnswer)

        const ignoreOffer =
          isOffer && (this.makingOffer || !isStable) && this.impolite

        if (ignoreOffer) {
          this.debug('ignored offer')
          this.ignoredOffer = true
          return
        } else {
          this.ignoredOffer = false
        }

        this.settingRemoteAnswer = isAnswer

        this.debug(`remote signal, type=`, signalData.signal.type)

        try {
          await this.peer.setRemoteDescription(signalData.signal)
        } catch (error) {
          this.debug(`Failed signal:`, signalData.signal)
          this.catchError('ERR_SET_REMOTE_DESCRIPTION')(error)
          return
        } finally {
          this.settingRemoteAnswer = false
        }

        // --------------------------
        if (isOffer) {
          // Add tracks before answer
          await this.addInitialTracks()

          // Flush ICE
          await this.flushIceCandidatesQueue()

          let answer = await this.peer.createAnswer()
          let changedAnswer = this.sdpTransform(answer)

          await this.peer
            .setLocalDescription(changedAnswer)
            .catch(this.catchError('ERR_SET_LOCAL_DESCRIPTION'))

          return this.sendSignal({
            signal: this.peer.localDescription || changedAnswer,
          })
        } else if (isAnswer) {
          this.debug('-- set remote answer, negotiated --')
        }
        //----------
      }

      //ice
      if ('candidate' in signalData.signal) {
        let readyForIce = this.peer.remoteDescription?.type

        if (!readyForIce || this.flushingIceQueue) {
          // Push to queue
          this.addToIceCandidatesQueue(signalData.signal)
        } else {
          // ensure queue is flushed
          await this.flushIceCandidatesQueue()

          // set
          try {
            await this.peer?.addIceCandidate(signalData.signal)
            this.debug('ice applied', signalData.signal.sdpMLineIndex)
          } catch (error) {
            if (this.ignoredOffer) {
              return
            }

            this.failed(RtcPeer.errorCode(error, 'ERR_ADD_ICE_CANDIDATE'))
          }
        }
      }
    } catch (error) {
      this.failed(RtcPeer.errorCode(error, 'ERR_SET_REMOTE_DESCRIPTION'))
    }
  }

  addToIceCandidatesQueue(candidate: RTCIceCandidateInit) {
    this.iceCandidatesQueue.push(candidate)
  }

  async flushIceCandidatesQueue() {
    this.flushingIceQueue = true
    for (let candidate of this.iceCandidatesQueue) {
      if (this.destroyed) break // because async

      // Not "await"ing because WebRTC queues internally & this way we'll reduce race condition surface area
      this.peer
        ?.addIceCandidate(candidate)
        .then(() => {
          this.debug('ice applied', candidate.sdpMLineIndex)
        })
        .catch(error => {
          this.debug(
            '[ignored error] Error flushing candidate:',
            error,
            candidate,
          )
        })
    }

    this.iceCandidatesQueue = []
    this.flushingIceQueue = false
  }

  /** Called  after remote offer was set */
  private async addInitialTracks() {
    if (!this.peer || this.destroyed) return

    for (let [trackName, config] of this.localTracks) {
      if (config.track) {
        // Add track
        this.addTrack(trackName, config.track)
      } else {
        // TODO: Warm up
        this.warmUpTransceiver(trackName)
      }
    }
  }

  setupDataChannel(dataChannel: RTCDataChannel | undefined) {
    if (this.destroyed) return

    if (!dataChannel) {
      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
      // which is invalid behavior. Handle it gracefully.
      // See: https://github.com/feross/simple-peer/issues/163
      return this.failed(
        RtcPeer.errorCode(
          new Error('Data channel event is missing `channel` property'),
          'ERR_DATA_CHANNEL',
        ),
      )
    }

    // set data channel
    this.dataChannel = dataChannel

    dataChannel.binaryType = 'arraybuffer'

    this.debug('setting up data')

    if (typeof dataChannel.bufferedAmountLowThreshold === 'number') {
      dataChannel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT
    }

    // eslint-disable-next-line unicorn/prefer-add-event-listener
    dataChannel.onmessage = event => {
      this.handleChannelMessage(event)
    }

    dataChannel.onbufferedamountlow = () => {
      this.debug('buffered amount low (@mo: ping)')
    }

    // eslint-disable-next-line unicorn/prefer-add-event-listener
    dataChannel.onopen = () => {
      this.onChannelStatusChange()
    }
    dataChannel.onclose = () => {
      this.onChannelStatusChange()
    }
    // eslint-disable-next-line unicorn/prefer-add-event-listener
    dataChannel.onerror = event => {
      if (this.destroyed || this.destroying) return
      console.warn(
        'datachannel onerror',
        this.peer?.signalingState,
        this.peer?.connectionState,
      )
      this.failed(RtcPeer.errorCode(event.error, 'ERR_DATA_CHANNEL'))
    }
  }

  private handleDataChannel(event: RTCDataChannelEvent) {
    this.debug('got datachannel event')
    this.setupDataChannel(event.channel)
  }

  private handleInternalMessages(data: InternalDataMessage) {
    if (!('__type' in data)) return

    switch (data.__type) {
      case 'signal':
        this.setRemoteSignal(data.payload)
        return
      case 'close':
        this.destroy()
        return
    }
  }

  // Channel
  private handleChannelMessage(event: MessageEvent<any>) {
    if (this.destroyed) return
    let data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    if (typeof data === 'object' && '__type' in data) {
      this.handleInternalMessages(data)
    } else {
      this.emit('data', data)
    }
  }

  private onChannelStatusChange() {
    if (!this.dataChannel || this.destroyed || this.destroying) return
    let readyState = this.dataChannel?.readyState

    this.debug('channel status change', this.dataChannel?.readyState)

    if (readyState === 'open') {
      this.debug('on channel open')
      this.emit('dataOpen')
      this.channelReady = true
      this.connectionReady = true
      this.setConnectionState('connected')
    } else if (readyState === 'closing' || readyState === 'closed') {
      this.debug(`on channel ${readyState}`)
      this.channelReady = false

      this.failed(
        RtcPeer.errorCode(new Error('Channel closed'), 'ERR_DATA_CHANNEL'),
      )
    }
  }
  // End of channel

  private async handleNegotiationNeeded() {
    if (this.destroying || this.destroyed || !this.peer) return

    const currentNegotiationNo = ++this.negotiationCount

    if (this.peer.signalingState !== 'stable') {
      this.debug(
        '[warm] ignored negotiation needed that was called in signalingState=',
        this.peer.signalingState,
      )
      return
    }

    if (this.makingOffer) {
      return
    }

    try {
      this.makingOffer = true

      let createdOffer = await this.peer.createOffer()

      let offer = this.sdpTransform(createdOffer)

      if (this.peer.signalingState !== 'stable') {
        this.debug('[warn] stopping negotiation midway')
        return
      }

      if (currentNegotiationNo !== this.negotiationCount) {
        this.debug('[warn] closed old ONN (negotiation needed)')
        return
      }

      await this.peer.setLocalDescription(offer)

      // must check after set local dec
      if (this.peer.localDescription?.type === 'offer') {
        this.debug('negotiationneeded worked')
      } else {
        this.debug('[error] negotiationneeded raced with message')
        throw new Error('negotiationneeded raced')
      }

      this.sendSignal({
        signal: this.peer.localDescription || offer,
      })
    } catch (error) {
      this.debug('negotiation needed failed:', error)
      this.failed(error)
    } finally {
      this.makingOffer = false
    }
  }

  private handleSignalingStateChange() {
    if (!this.peer) return

    this.debug('signalingStateChange %s', this.peer.signalingState)

    switch (this.peer.signalingState) {
      case 'closed':
      case 'stable':
        this.stopOfferTimeout()
        break
    }
  }

  sendJson(payload: Jsonable) {
    if (this.dataChannel?.readyState === 'open') {
      let raw = JSON.stringify(payload)
      this.dataChannel?.send(raw)
    }
  }

  private sendSignal({ signal }: { signal: SignalData }) {
    let payload = {
      signal,
      pairId: this.currentPairId,
    }

    if (
      'type' in signal &&
      signal.type === 'offer' &&
      // only do so on initialNegotiation
      this.state === 'connecting' &&
      !this.connectionReady &&
      !this.channelReady
    ) {
      this.startOfferTimeout()
    }

    if (
      this.connectionReady &&
      this.channelReady &&
      this.dataChannel?.readyState === 'open'
    ) {
      this.sendJson({
        __type: 'signal',
        payload,
      } as InternalDataMessage)
    } else {
      this.emit('signal', payload)
    }
    this.debug(
      `sent signal (type: ${
        'type' in payload.signal ? payload.signal.type : 'ice'
      }, at: ${new Date().toISOString()})`,
    )
  }

  async restartIce() {
    if (this.destroyed) return
    if (!this.peer) return

    this.debug(`Restarting ICE`)

    this.restartingIce = true
    this.startIceRestartTimeout()

    if ('restartIce' in this.peer) {
      // @ts-ignore
      this.peer.restartIce()
    } else {
      // HACK: support safari mobile
      let offer

      try {
        // Use the old way to restart ice
        offer = await this.peer.createOffer({ iceRestart: true })
      } catch (error) {
        this.failed(RtcPeer.errorCode(error, 'ERR_CREATE_OFFER'))
      }

      if (!offer) return

      try {
        await this.peer.setLocalDescription(offer)
      } catch (error) {
        this.failed(RtcPeer.errorCode(error, 'ERR_SET_LOCAL_DESCRIPTION'))
      }

      // Send initial offer!
      this.sendSignal({ signal: offer })
    }
  }

  private setConnectionState(state: RtcConnectionStateType) {
    if (this.state === state) {
      return
    }

    // Note: DO NOT MOVE
    // Even if we're connecting, and new connecting is emitted, restart connection timeout, so it must come before the if below
    // if (state === 'connecting' && !this.destroyed) {
    //   this.startConnectionTimeout()
    // }

    if (state === 'connected') {
      // reset attempt for new timers
      this.recreateAttempt = 1
      this.stopOfferTimeout()
      this.stopIceRestartTimeout()
      this.stopConnectionTimeout()

      this.startNoMediaTimeout()
    }

    if (state === 'closed') {
      this.stopOfferTimeout()
      this.stopConnectionTimeout()
      this.stopNoMediaTimeout()
    }

    this.state = state
    this.debug(`connectionStateChange=`, state)
    this.emit('connectionStateChange', state)
  }

  iceRestartTimeoutId: number | undefined
  /** Timeout for sent offer from the moment you send */
  private startIceRestartTimeout() {
    this.stopIceRestartTimeout()
    this.iceRestartTimeoutId = setTimeout(() => {
      this.failed(
        RtcPeer.errorCode(
          new Error('Ice restart failed.'),
          'ERR_ICE_RESTART_FAILURE',
        ),
        { backOff: false },
      )
    }, ICERESTART_TIMEOUT)
  }
  private stopIceRestartTimeout() {
    if (this.iceRestartTimeoutId) {
      clearTimeout(this.iceRestartTimeoutId)
      this.iceRestartTimeoutId = undefined
    }
  }

  noMediaTimeoutAt: number | undefined = undefined
  /** Timeout for receiving a media AFTER connected event */
  private startNoMediaTimeout() {
    if (this.remoteTracks.size >= 1) {
      // if we've got tracks, ignore
      return
    }
    this.debug('no media timeout started counting', new Date().toISOString())
    this.stopNoMediaTimeout()
    this.noMediaTimeoutAt = setTimeout(() => {
      this.failed(new Error(`No media received within ${NO_MEDIA_TIMEOUT}ms.`))
    }, NO_MEDIA_TIMEOUT)
  }
  private stopNoMediaTimeout() {
    if (this.noMediaTimeoutAt) {
      clearTimeout(this.noMediaTimeoutAt)
      this.noMediaTimeoutAt = undefined
    }
  }

  /** Performance.now() time */
  offerTimeoutId: number | undefined
  /** Timeout for sent offer from the moment you send */
  private startOfferTimeout() {
    this.stopOfferTimeout()

    // only timeout offers on the impolite peer
    if (!this.initialOfferer) {
      return
    }

    let delay = this.exponentialFactor + OFFER_TIMEOUT_MIN
    this.offerTimeoutId = setTimeout(() => {
      this.failed(
        RtcPeer.errorCode(
          new Error(`Offer timeout (got no remote answer after ${delay}ms)`),
          'ERR_SIGNALING',
        ),
        { backOff: false },
      )
    }, delay)
  }
  private stopOfferTimeout() {
    if (this.offerTimeoutId) {
      clearTimeout(this.offerTimeoutId)
      this.offerTimeoutId = undefined
    }
  }

  connectionTimeoutId: number | undefined
  /** Timeout for sent offer from the moment you send */
  private startConnectionTimeout() {
    this.stopConnectionTimeout()
    if (this.destroyed) return
    this.debug('started connection timeout')

    let delay =
      CONNECTION_TIMEOUT +
      // on the receiving end, add some time so we don't timeout at the same time
      (!this.initialOfferer ? ms('2s') : 0)

    let currentId = this.id
    this.connectionTimeoutId = setTimeout(() => {
      if (currentId !== this.id) return

      this.failed(
        RtcPeer.errorCode(
          new Error(`Connection timeout (Could not connect ${delay}ms)`),
          'ERR_CONNECTION_FAILURE',
        ),
        { backOff: false },
      )
    }, delay)
  }
  private stopConnectionTimeout() {
    if (this.connectionTimeoutId) {
      clearTimeout(this.connectionTimeoutId)
      this.connectionTimeoutId = undefined
    }
  }

  private stopTimers() {
    this.stopRecreating()
    this.stopIceRestartTimeout()
    this.stopOfferTimeout()
    this.stopNoMediaTimeout()
    this.stopConnectionTimeout()
  }

  static errorCode = (error: Error, code: ErrorCodes) => {
    return errorCode(error, code)
  }

  private catchError(code: ErrorCodes) {
    return (error: Error) => this.failed(RtcPeer.errorCode(error, code))
  }

  closePeer(error?: Error) {
    this.debug('destroying peer (error: %s)', error && (error.message || error))

    // stop immediately
    this.stopTimers()

    this.destroyed = true
    this.connectionReady = false
    this.channelReady = false
    this.flushingIceQueue = false
    this.makingOffer = false
    this.restartingIce = false
    this.needsIceRestart = false
    this.currentPairId = undefined

    if (this.dataChannel) {
      try {
        this.dataChannel.close()
      } catch (_) {}

      // allow events concurrent with destruction to be handled
      // eslint-disable-next-line unicorn/prefer-add-event-listener
      this.dataChannel.onmessage = null
      // eslint-disable-next-line unicorn/prefer-add-event-listener
      this.dataChannel.onopen = null
      this.dataChannel.onclose = null
      // eslint-disable-next-line unicorn/prefer-add-event-listener
      this.dataChannel.onerror = null
    }

    if (this.peer) {
      try {
        this.peer.close()
        this.debug('closed peer')
      } catch (_) {}

      // From simple peer: allow events concurrent with destruction to be handled
      this.peer.removeEventListener(
        'connectionstatechange',
        this.handleConnectionStateChange,
      )
      this.peer.removeEventListener('icecandidate', this.handleIceCandidate)
      this.peer.removeEventListener('track', this.handleTrack)
      this.peer.removeEventListener(
        'iceconnectionstatechange',
        this.handleIceConnectionStateChange,
      )
      this.peer.removeEventListener(
        'icegatheringstatechange',
        this.handleIceGatheringStateChange,
      )
      this.peer.removeEventListener('datachannel', this.handleDataChannel)
      this.peer.removeEventListener(
        'negotiationneeded',
        this.handleNegotiationNeeded,
      )
      this.peer.removeEventListener(
        'signalingstatechange',
        this.handleSignalingStateChange,
      )

      this.peer = undefined
      this.dataChannel = undefined
    }

    // Remote tracks
    for (let track of this.remoteTracks) {
      track.stop()
    }

    this.ignoredOffer = false
    this.settingRemoteAnswer = false
    this.remoteTracks = new Set()
    this.senders = new Map()
    this.iceCandidatesQueue = []
  }

  recreateTimerId?: number
  recreateAttempt?: number

  get exponentialFactor() {
    let minimum = 400
    let maximum = 32000
    let attempt = this.recreateAttempt || 1
    let random = Math.floor(Math.random() * (1500 - 300) + 300)
    /** Pick a number between 100 - 200 */
    let reasonableMultiplier = 500

    let delay = Math.min(
      Math.max(Math.pow(2, attempt) * reasonableMultiplier + random, minimum),
      maximum,
    )

    this.debug('delay=', delay)

    return delay
  }

  stopRecreating() {
    if (this.recreateTimerId) {
      clearTimeout(this.recreateTimerId)
      this.recreateTimerId = undefined
    }
  }

  recreatePeer() {
    this.recreateAttempt = Number(this.recreateAttempt) + 1
    this.debug(`recreating (attempt: ${this.recreateAttempt})`)
    this.closePeer()
    this.startPeerConnection()
  }

  failed(error?: Error, options: { backOff: boolean } = { backOff: true }) {
    this.setConnectionState('closed')

    if (!this.recreateAttempt) {
      this.recreateAttempt = 1
    }

    if (this.recreateAttempt > 12) {
      this.debug('MAX ATTEMPT EXCEEDED')
      this.destroy(error)
      return
    }

    // Log
    this.debug(`[peer failed] Attempt: ${this.recreateAttempt || 0}`, error)
    if (error) {
      console.warn('rtc error:', error)
    }

    this.stopRecreating()
    this.closePeer()

    if (options.backOff) {
      this.recreateTimerId = setTimeout(() => {
        this.recreateAttempt = Number(this.recreateAttempt) + 1
        this.startPeerConnection()
      }, this.exponentialFactor + 200)
    } else {
      this.recreateAttempt = Number(this.recreateAttempt) + 1
      this.startPeerConnection()
    }
  }

  destroy(error?: Error) {
    this.destroying = true

    this.setConnectionState('closed')
    this.stopRecreating()
    this.closePeer()

    if (error) {
      console.error('RTCPeer destroyed:', error)
      this.emit('error', error)
    }
  }

  debug(arg: string, ...args: any[]) {
    debug(`${this.id} | ${arg}`, ...args)
  }
}

function generatePairId() {
  return Math.floor(Date.now() / 1000 + Math.round(Math.random() * 1000))
}

// Peer DataChannel closing interval
// HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
// https://bugs.chromium.org/p/chromium/issues/detail?id=882743
// if (
//   participant.dataChannel &&
//   participant.dataChannel.readyState === 'closing'
// ) {
//   let channel = participant.dataChannel
//   let userId = participant.userId
//   if (channel && channel.readyState === 'closing') {
//     if (
//       participant.channelClosing &&
//       participant.channelClosingAt &&
//       participant.channelClosingAt + CHANNEL_CLOSING_TIMEOUT <
//         performanceNow
//     ) {
//       // timeout passed
//       dispatch({
//         type: 'peer disconnected',
//         userId,
//       })
//     } else {
//       dispatch({
//         type: 'peer channel closing changed',
//         userId,
//         closing: true,
//       })
//     }
//   } else {
//     dispatch({
//       type: 'peer channel closing changed',
//       userId,
//       closing: false,
//     })
//   }
// }
